# Indonesian translations for PACKAGE package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2025-09-04 11:19+0500\n"
"PO-Revision-Date: 2025-09-04 11:19+0500\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: id\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title #
#: en/structure/action.md
#, no-wrap
msgid "Actions"
msgstr ""

#. type: Plain text
#: en/structure/action.md
msgid "In a web application, the request URL determines what's executed. Matching is made by a router configured with multiple routes. Each route can be attached to a middleware that, given request, produces a response. Since middleware overall could be chained and can pass actual handling to the next middleware, we call the middleware actually doing the job an action."
msgstr ""

#. type: Plain text
#: en/structure/action.md
msgid "There are multiple ways to describe an action. The simplest one is using a closure:"
msgstr ""

#. type: Fenced code block (php)
#: en/structure/action.md
#, no-wrap
msgid ""
"use \\Psr\\Http\\Message\\ServerRequestInterface;\n"
"use \\Psr\\Http\\Message\\ResponseInterface;\n"
"use Yiisoft\\Router\\Route;\n"
"\n"
"Route::get('/')->action(function (ServerRequestInterface $request) use ($responseFactory): ResponseInterface {\n"
"    $response = $responseFactory->createResponse();\n"
"    $response->getBody()->write('You are at homepage.');\n"
"    return $response;\n"
"});\n"
msgstr ""

#. type: Plain text
#: en/structure/action.md
msgid "It's fine for simple handling since any more complicated one would require getting dependencies, so a good idea would be moving the handling to a class method. Callback middleware could be used for the purpose:"
msgstr ""

#. type: Fenced code block (php)
#: en/structure/action.md
#, no-wrap
msgid ""
"use Yiisoft\\Router\\Route;\n"
"\n"
"Route::get('/')->action([FrontPageAction::class, 'run']),\n"
msgstr ""

#. type: Plain text
#: en/structure/action.md
msgid "The class itself would be like:"
msgstr ""

#. type: Fenced code block (php)
#: en/structure/action.md
#, no-wrap
msgid ""
"use \\Psr\\Http\\Message\\ServerRequestInterface;\n"
"use \\Psr\\Http\\Message\\ResponseInterface;\n"
"\n"
"final readonly class FrontPageAction\n"
"{\n"
"    public function run(ServerRequestInterface $request): ResponseInterface\n"
"    {\n"
"        // build response for a front page    \n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: en/structure/action.md
msgid "For many cases, it makes sense to group handling for many routes into a single class:"
msgstr ""

#. type: Fenced code block (php)
#: en/structure/action.md
#, no-wrap
msgid ""
"use Yiisoft\\Router\\Route;\n"
"\n"
"Route::get('/post/index')->action([PostController::class, 'actionIndex']),\n"
"Route::get('/post/view/{id:\\d+}')->action([PostController::class, 'actionView']),\n"
msgstr ""

#. type: Plain text
#: en/structure/action.md
msgid "The class itself would look like the following:"
msgstr ""

#. type: Fenced code block (php)
#: en/structure/action.md
#, no-wrap
msgid ""
"use \\Psr\\Http\\Message\\ServerRequestInterface;\n"
"use \\Psr\\Http\\Message\\ResponseInterface;\n"
"\n"
"final readonly class PostController\n"
"{\n"
"    public function actionIndex(ServerRequestInterface $request): ResponseInterface\n"
"    {\n"
"        // render posts list\n"
"    }\n"
"    \n"
"    \n"
"    public function actionView(ServerRequestInterface $request): ResponseInterface\n"
"    {\n"
"        // render a single post      \n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: en/structure/action.md
msgid "We usually call such a class \"controller.\""
msgstr ""

#. type: Title ##
#: en/structure/action.md
#, no-wrap
msgid "Autowiring"
msgstr ""

#. type: Plain text
#: en/structure/action.md
#, no-wrap
msgid ""
"Both constructors of action-classes and action-methods are automatically getting services from\n"
" the dependency injection container:\n"
msgstr ""

#. type: Fenced code block (php)
#: en/structure/action.md
#, no-wrap
msgid ""
"use \\Psr\\Http\\Message\\ServerRequestInterface;\n"
"use \\Psr\\Http\\Message\\ResponseInterface;\n"
"use Psr\\Log\\LoggerInterface;\n"
"\n"
"final readonly class PostController\n"
"{\n"
"    public function __construct(\n"
"        private PostRepository $postRepository\n"
"    )\n"
"    {\n"
"    }\n"
"\n"
"    public function actionIndex(ServerRequestInterface $request, LoggerInterface $logger): ResponseInterface\n"
"    {\n"
"        $logger->debug('Rendering posts list');\n"
"        // render posts list\n"
"    }\n"
"    \n"
"    \n"
"    public function actionView(ServerRequestInterface $request): ResponseInterface\n"
"    {\n"
"        // render a single post      \n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: en/structure/action.md
msgid "In the above example `PostRepository` is injected automatically via constructor. That means it is available in every action. Logger is injected into `index` action only."
msgstr ""
