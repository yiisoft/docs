# Russian translations for PACKAGE package
# Copyright (C) 2025 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Automatically generated, 2025.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2025-09-11 10:15+0500\n"
"PO-Revision-Date: 2025-09-04 11:19+0500\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

#. type: Title #
#: ../../guide/en/concept/immutability.md
#, no-wrap
msgid "Immutability"
msgstr ""

#. type: Plain text
#: ../../guide/en/concept/immutability.md
msgid "Immutability means an object's state cannot change after it has been created.  Instead of modifying an instance, you create a new instance with the desired changes.  This approach is common for value objects such as Money, IDs, and DTOs. It helps to avoid accidental side effects: methods cannot silently change shared state, which makes code easier to reason about."
msgstr ""

#. type: Title ##
#: ../../guide/en/concept/immutability.md
#, no-wrap
msgid "Mutable pitfalls (what we avoid)"
msgstr ""

#. type: Fenced code block (php)
#: ../../guide/en/concept/immutability.md
#, no-wrap
msgid ""
"// A shared base query built once and reused:\n"
"$base = Post::find()->where(['status' => Post::STATUS_PUBLISHED]);\n"
"\n"
"// Somewhere deep in the code we only need one post:\n"
"$one = $base->limit(1)->one(); // mutates the underlying builder (sticky limit!)\n"
"\n"
"// Later we reuse the same $base expecting a full list:\n"
"$list = $base->orderBy(['created_at' => SORT_DESC])->all();\n"
"// Oops: still limited to 1 because the previous limit(1) modified $base.\n"
msgstr ""

#. type: Title ##
#: ../../guide/en/concept/immutability.md
#, no-wrap
msgid "Creating an immutable object in PHP"
msgstr ""

#. type: Plain text
#: ../../guide/en/concept/immutability.md
msgid "There is no direct way to modify an instance, but you can use clone to create a new instance with the desired changes.  That is what `with*` methods do."
msgstr ""

#. type: Fenced code block (php)
#: ../../guide/en/concept/immutability.md
#, no-wrap
msgid ""
"final class Money\n"
"{\n"
"    public function __construct(\n"
"        private int $amount,\n"
"        private string $currency,\n"
"    ) {\n"
"        $this->validateAmount($amount);\n"
"        $this->validateCurrency($currency);\n"
"    }\n"
"    \n"
"    private function validateAmount(string $amount) \n"
"    {\n"
"     if ($amount < 0) {\n"
"            throw new InvalidArgumentException('Amount must be positive.');\n"
"        }\n"
"    }\n"
"    \n"
"    private function validateCurrency(string $currency)\n"
"    {\n"
"        if (!in_array($currency, ['USD', 'EUR'])) {\n"
"            throw new InvalidArgumentException('Invalid currency. Only USD and EUR are supported.');\n"
"        }\n"
"    } \n"
"\n"
"    public function withAmount(int $amount): self\n"
"    {\n"
"        $this->validateAmount($amount);\n"
"    \n"
"        if ($amount === $this->amount) {\n"
"            return $this;\n"
"        }\n"
"    \n"
"        $clone = clone $this;\n"
"        $clone->amount = $amount;\n"
"        return $clone;\n"
"    }\n"
"    \n"
"    public function withCurrency(string $currency): self\n"
"    {\n"
"        $this->validateCurrency($currency);\n"
"    \n"
"        if ($currency === $this->currency) {\n"
"            return $this;\n"
"        }\n"
"    \n"
"        $clone = clone $this;\n"
"        $clone->currency = $currency;\n"
"        return $clone;\n"
"    }\n"
"    \n"
"    public function amount(): int \n"
"    {\n"
"        return $this->amount;\n"
"    }\n"
"    \n"
"    public function currency(): string \n"
"    {\n"
"        return $this->currency;\n"
"    }\n"
"\n"
"    public function add(self $money): self\n"
"    {\n"
"        if ($money->currency !== $this->currency) {\n"
"            throw new InvalidArgumentException('Currency mismatch. Cannot add money of different currency.');\n"
"        }\n"
"        return $this->withAmount($this->amount + $money->amount);\n"
"    }\n"
"}\n"
"\n"
"$price = new Money(1000, 'USD');\n"
"$discounted = $price->withAmount(800);\n"
"// $price is still 1000 USD, $discounted is 800 USD\n"
msgstr ""

#. type: Bullet: '- '
#: ../../guide/en/concept/immutability.md
msgid "We mark the class `final` to prevent subclass mutations; alternatively, design for extension carefully."
msgstr ""

#. type: Bullet: '- '
#: ../../guide/en/concept/immutability.md
msgid "Validate in the constructor and `with*` methods so every instance is always valid."
msgstr ""

#. type: Plain text
#: ../../guide/en/concept/immutability.md
#, no-wrap
msgid ""
"> [!TIP]\n"
"> If you define a simple DTO, you can use modern PHP `readonly` and leave properties `public`. The `readonly` keyword\n"
"> would ensure that the properties cannot be modified after the object is created.\n"
msgstr ""

#. type: Title ##
#: ../../guide/en/concept/immutability.md
#, no-wrap
msgid "Using clone (and why it is inexpensive)"
msgstr ""

#. type: Plain text
#: ../../guide/en/concept/immutability.md
msgid "PHP's clone performs a shallow copy of the object. For immutable value objects that contain only scalars or other immutable objects, shallow cloning is enough and fast. In modern PHP, cloning small value objects is inexpensive in both time and memory."
msgstr ""

#. type: Plain text
#: ../../guide/en/concept/immutability.md
msgid "If your object holds mutable sub-objects that must also be copied, implement `__clone` to deep-clone them:"
msgstr ""

#. type: Fenced code block (php)
#: ../../guide/en/concept/immutability.md
#, no-wrap
msgid ""
"final class Order\n"
"{\n"
"    public function __construct(\n"
"        private Money $total\n"
"    ) {}\n"
"    \n"
"    public function total(): Money \n"
"    {\n"
"        return $this->total;\n"
"    }\n"
"\n"
"    public function __clone(): void\n"
"    {\n"
"        // Money is immutable in our example, so a deep clone is not required.\n"
"        // If it were mutable, you could do: $this->total = clone $this->total;\n"
"    }\n"
"\n"
"    public function withTotal(Money $total): self\n"
"    {\n"
"        $clone = clone $this;\n"
"        $clone->total = $total;\n"
"        return $clone;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Title ##
#: ../../guide/en/concept/immutability.md
#, no-wrap
msgid "Usage style"
msgstr ""

#. type: Bullet: '- '
#: ../../guide/en/concept/immutability.md
msgid "Build a value object once and pass it around. If you need a change, use a `with*` method that returns a new instance."
msgstr ""

#. type: Bullet: '- '
#: ../../guide/en/concept/immutability.md
msgid "Prefer scalar/immutable fields inside immutable objects; if a field can mutate, isolate it and deep-clone in `__clone` when needed."
msgstr ""

#. type: Plain text
#: ../../guide/en/concept/immutability.md
msgid "Immutability aligns well with Yii's preference for predictable, side-effect-free code and makes services, caching, and configuration more robust."
msgstr ""
